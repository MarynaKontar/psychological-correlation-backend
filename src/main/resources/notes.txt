App has three model levels:
entities (saved in db)
objects (for collecting and transform data from db collections)
dto (for hiding implementation details from app user)

But not all entities have corresponding objects, for example, ValueCompatibilityAnswersEntity
and User. They don`t have objects, but have corresponding dto,
because we are transformed and added it to another objects:
UserAccount, ValueProfileIndividual, ValueProfileMatching.

Because all of these, both entities and objects extends from AbstractEntity (no AbstractObject).
And this let have AbstractDtoConverter with global methods for converting
from objects(and some entities) to dto and vise versa.

Absence of AbstractObject and corresponding objects for ValueCompatibilityAnswersEntity
and User isn`t good architectural solution, but in another case
there will be redundant transformations and classes.
While i leave it in this form, then i will decide which is more suitable.

TokenEntity -> nothing
User -> SimpleUserDto
ValueCompatibilityAnswersEntity -> ValueCompatibilityAnswersDto

UserAccountEntity -> UserAccount -> UserAccountDto
UserMatchEntity -> UserMatch -> UserMatchDto
CredentialsEntity -> Credentials -> CredentialsDto

Another entities, objects and dtos are just embedded for more global classes.


ENDPOINTS:
GET:
/test/initTest
/test/generateTokenList
/account/getAllRegisteredAndPassedTestUsersForMatching
/account/getAllRegisteredAndPassedTestUsers
/match/getUsersForMatching

POST:
/test/goal
/test/state
/test/quality
/test/value-profile

/registration
/user/anonimRegistration
/registration/changePassword
/auth/login
/auth/loginFriendAccount
/account/inviteForMatching

/match/Percent
/match/Pearson
/match/value-profile-for-matching

PUT:
/account













Delete user when return to friend accout without registration.

//    @Query("{$find: {'userId': ?0, 'passed': ?1}, $sort: {'passDate': -1}, $limit: 1}")

https://drive.google.com/file/d/1XlljdGSgrBI2bKiqZJ5TVxPLzHoXacI0/view?usp=sharing

Replace Credentials to security directory?








============= Security=============
С фронтенда приходит запрос с токеном в хедере. Если данный endpoint is not secure, то пропускается фильтром (TokenAuthFilter) дальше, если же secure, то запускается аутентификация:
authenticated method in  AuthenticationManager -> authenticate method in TokenAuthProvider ->
в метод передается AuthorisationToken (impl Authentication), из него берется токен  (getPrincipal), затем токен ищется в базе данных, ищется его юзер, проверяется не истек ли срок токена, и если все нормально, то ,берется tokenPrincipal = (TokenPrincipal) userDetailsService.loadUserByUsername(user.getName())  и создается новый AuthorisationToken но уже с setAuthenticated(true).


При этом AuthorisationToken создается так, что у него нет credentials (=null):
private AuthorisationToken(String token) {
        super(token, null);
    }
А principal у него - это token.

In TokenAuthFilter мы вынимаем токен из хедера и  запускает процесс аутентификации:
Authentication authenticateResult = getAuthenticationManager().authenticate(authorisationToken);

 и он кастомно продолжается в TokenAuthProvider










 @Override
     public Page<UserAccount> getAllRegisteredAndPassedTestPageable(Pageable pageable) { // only thus who is registered (have userAccount) and passed test

         LookupOperation lookupOperation = LookupOperation.newLookup()
                 .from("valueCompatibilityAnswersEntity")
                 .localField("userId")
                 .foreignField("userId")
                 .as("userAccountEntityInfo");


         FacetOperation facetOperation = facet(
                 Aggregation.skip(((pageable.getPageNumber())*pageable.getPageSize())),
                 Aggregation.limit(pageable.getPageSize())
         ).as("userAccountEntity")
                 .and(
                         count().as("count")
                 ).as("COUNT");

         Fields fields = Fields.fields("_id", "userId", "accountType");
         Aggregation aggregation = Aggregation.newAggregation(
                 Aggregation.match(Criteria.where("userId").ne(userService.getPrincipalUser().getId())),
                 lookupOperation,
                 unwind("userAccountEntityInfo"),
                 Aggregation.match(Criteria.where("userAccountEntityInfo").ne(null)),
                 Aggregation.match(Criteria.where("userAccountEntityInfo.passed").is(true)),
                 group(fields).addToSet("userId").as("userIds")
 //                project(fields),
 //                Aggregation.sort(Sort.Direction.DESC, "userId")
 //                facetOperation
 //                Aggregation.skip(((pageable.getPageNumber())*pageable.getPageSize())),
 //                Aggregation.limit(pageable.getPageSize())
                 );

         AggregationResults<Document> aggregationResultDoc = mongoOperations.aggregate(aggregation, "userAccountEntity", Document.class);
         Document aggregationResult = aggregationResultDoc.getUniqueMappedResult();
         List<Document> documentResults =  (List<Document>) aggregationResult.get("userAccountEntity");
         List<UserAccountEntity> results = new ArrayList<>();
         documentResults.forEach(document -> results.add((UserAccountEntity) document.get("fg")));
 //        ArrayList<LinkedHashMap<String,Integer>> countListMap = (ArrayList<LinkedHashMap<String, Integer>>) uniqueMappedResult.get(0);
 //        LinkedHashMap<String,Integer> countMap = (LinkedHashMap<String,Integer>) uniqueMappedResult.get(1);
         LinkedHashMap<String,Integer> count = (LinkedHashMap<String,Integer>) aggregationResult.get("COUNT");


 //        AggregationResults<UserAccountEntity> aggregationResults = mongoOperations.aggregate(aggregation, "userAccountEntity", UserAccountEntity.class);
 //        List<UserAccountEntity> results = aggregationResults.getMappedResults();
         List<UserAccount> userAccounts = results.stream()
                 .map(userAccountEntity -> getUserAccount(userAccountEntity))
                 .collect(Collectors.toList());

         Page<UserAccount> page = new PageImpl<UserAccount>(userAccounts, pageable, getAllRegisteredAndPassedTest().size());
         return page;
     }


















     ==============TESTING==================

        <!--<dependency>-->
            <!--<groupId>org.powermock</groupId>-->
            <!--<artifactId>powermock-api-mockito2</artifactId>-->
            <!--<version>1.7.4</version>-->
        <!--</dependency>-->
        <!--<dependency>-->
            <!--<groupId>org.powermock</groupId>-->
            <!--<artifactId>powermock-module-junit4</artifactId>-->
            <!--<version>2.0.2</version>-->
        <!--</dependency>-->


     //        PowerMockito.mockStatic(Enum.class);
     //        PowerMockito.when(Enum.valueOf(ImportOrderOption.class,"TOP")).thenReturn(ImportOrderOption.TOP);

     //        when(TokenType.valueOf(TokenType.class, "INVITE_TOKEN")).thenReturn(TokenType.INVITE_TOKEN);

     //        TokenType T = PowerMockito.mock(TokenType.class);
     //        Whitebox.setInternalState(T, "name", "NEW_TOKEN_TYPE");
     //        Whitebox.setInternalState(T, "ordinal", 4);
     //        PowerMockito.mockStatic(TokenType.class);
     //        PowerMockito.when(TokenType.values()).thenReturn(new TokenType[]{
     //                TokenType.INVITE_TOKEN, TokenType.ACCESS_TOKEN,TokenType.REFRESH_TOKEN});
     //
     //        PowerMockito.mockStatic(Enum.class);
     //        PowerMockito.when(Enum.valueOf(TokenType.class,"INVITE_TOKEN")).thenReturn(TokenType.INVITE_TOKEN);
     //        PowerMockito.when(Enum.valueOf(TokenType.class,"ACCESS_TOKEN")).thenReturn(TokenType.ACCESS_TOKEN);
     //        PowerMockito.when(Enum.valueOf(TokenType.class,"REFRESH_TOKEN")).thenReturn(TokenType.REFRESH_TOKEN);
     ////        PowerMockito.when(Enum.valueOf(TokenType.class,"NEW_TOKEN_TYPE")).thenReturn(T);
     //        PowerMockito.mockStatic(TokenType.class);
     //        PowerMockito.when(TokenType.valueOf(TokenType.class,"INVITE_TOKEN")).thenReturn(TokenType.INVITE_TOKEN);






import org.springframework.test.annotation.DirtiesContext;
//@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)




import static org.junit.jupiter.api.Assertions.assertAll;
import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assumptions.assumeFalse;
import static org.junit.jupiter.api.Assumptions.assumingThat;
@Test
    void groupAssertions() {
        int[] numbers = {0, 1, 2, 3, 4};
        assertAll("numbers",
                () -> assertEquals(numbers[0], 1),
                () -> assertEquals(numbers[3], 3),
                () -> assertEquals(numbers[4], 1)
        );
    }

    @Test
    void falseAssumption() {
        assumeFalse(5 < 1);
        assertEquals(5 + 2, 7);
    }

    @Test
    void assumptionThat() {
        String someString = "Just a string";
        assumingThat(
                someString.equals("Just a string"),
                () -> assertEquals(2 + 2, 4)
        );
    }






            <!--Embedded mongodb -->
            <!--<dependency>-->
                <!--<groupId>de.flapdoodle.embed</groupId>-->
                <!--<artifactId>de.flapdoodle.embed.mongo</artifactId>-->
                <!--<scope>test</scope>-->
            <!--</dependency>-->


            Container for using mongodb for testing with docker
            <!-- https://mvnrepository.com/artifact/org.testcontainers/testcontainers -->
            <!--To create mongo container for testing with docker container-->
            <!--<dependency>-->
                <!--<groupId>org.testcontainers</groupId>-->
                <!--<artifactId>testcontainers</artifactId>-->
                <!--<version>1.12.1</version>-->
                <!--<scope>test</scope>-->
            <!--</dependency>-->


            Вместо DTO можно использовать
            <!--<dependency>-->
                <!--<groupId>org.modelmapper</groupId>-->
                <!--<artifactId>modelmapper</artifactId>-->
                <!--<version>${modelmapper.version}</version>-->
            <!--</dependency>-->



                    Manual mongodb dependencies
                    <!--<dependency>-->
                        <!--<groupId>org.mongodb</groupId>-->
                        <!--<artifactId>mongo-java-driver</artifactId>-->
                        <!--<version>3.11.0</version>-->
                    <!--</dependency>-->
                    <!--<dependency>-->
                        <!--<groupId>org.mongodb</groupId>-->
                        <!--<artifactId>mongodb-driver-core</artifactId>-->
                        <!--<version>3.11.0</version>-->
                    <!--</dependency>-->

                    <!--<dependency>-->
                        <!--<groupId>org.mongodb</groupId>-->
                        <!--<artifactId>bson</artifactId>-->
                        <!--<version>3.11.0</version>-->
                    <!--</dependency>-->


























                           //        Fixture.of(SimpleUserDto.class).addTemplate("registeredUserDto", new Rule() {{
                    //            add("name", "userName");
                    //            add("email", "email@gmail.com");
                    //            add("gender", "someGender");
                    //            add("age", 35);
                    //        }});

                    //        Fixture.of(UserAccountDto.class).addTemplate("userAccountDto", new Rule() {{
                    //            add("user", has(1).of(SimpleUserDto.class, "registeredUserDto"));
                    //            add("accountType", AccountType.OPEN);
                    //            add("isValueCompatibilityTestPassed", false);
                    //        }});
                    //
                    //        private List<String> inviteTokens;
                    //        private List<SimpleUserDto> usersForMatching;
                    //        private List<SimpleUserDto> usersWhoYouInvite;
                    //        private List<SimpleUserDto> usersWhoInvitedYou;


                        @BeforeEach
                        public void setUp() throws Exception {
                    //        MockitoAnnotations.initMocks(this);
                    //        mockMvc = MockMvcBuilders
                    //                .standaloneSetup(apiRegistrationController)
                    //                .addFilters(tokenAuthFilter)
                    //                .build();
                        }